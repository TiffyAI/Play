<!DOCTYPE html>
<html>
<head>
  <title>TiffyAI Interface</title>
  <script src="https://aframe.io/releases/1.2.0/aframe.min.js"></script>
  <style>
    body, html { margin: 0; padding: 0; height: 100%; overflow: hidden; }

    /* Loading Screen with drop.gif behind Tiffy */
    #loadingScreen {
      position: absolute;
      top:0;left:0;
      width:100%;height:100%;
      background:#000 url("drop.gif") center/cover no-repeat;
      color:white;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      z-index:20000;
      transition: opacity 1s ease;
    }
    #loadingScreen img {
      width:200px;
      border-radius:50%;
      box-shadow:0 0 30px #00f0ff;
      margin-bottom:10px;
    }
    #loadingScreen h2, #loadingScreen p {
      font-family:sans-serif;
      text-align:center;
      margin:6px 0;
    }
    .glass-input {
      background: rgba(255, 255, 255, 0.12);
      border: 1px solid rgba(255, 255, 255, 0.25);
      padding: 10px;
      border-radius: 12px;
      color: white;
      margin: 8px 0;
      font-size: 14px;
      width: 220px;
      text-align: center;
    }
    #startTiffy {
      margin-top:8px;
      padding:10px 18px;
      border:none;
      border-radius:10px;
      background:linear-gradient(135deg, #00f0ff, #0080ff);
      color:white;
      font-weight:bold;
      cursor:pointer;
      box-shadow:0 0 12px #00f0ff;
    }
    #changeName {
      margin-left:8px;
      padding:8px 10px;
      border-radius:8px;
      background: rgba(255,255,255,0.12);
      cursor: pointer;
      display:none;
    }

    .talking { animation: lipMove 0.28s infinite alternate; transform-origin: 50% 60%; }
    @keyframes lipMove {
      from { transform: scale(1,1); }
      to { transform: scale(1,0.92); }
    }

    /* Glass input panel */
    .glass-panel {
      position: absolute;
      bottom: 40px;
      left: 30%;
      transform: translateX(-50%);
      width: 55%;
      background: rgba(255, 255, 255, 0.08);
      border: 1px solid rgba(255, 255, 255, 0.18);
      backdrop-filter: blur(8px);
      border-radius: 12px;
      padding: 12px;
      color: white;
      font-family: sans-serif;
      display: flex;
      gap: 12px;
      align-items: center;
      z-index: 9999;
    }
    input[type="text"] {
      flex: 1;
      background: rgba(255, 255, 255, 0.12);
      border: none;
      color: white;
      padding: 8px;
      border-radius: 8px;
    }
    button {
      background: rgba(255,255,255,0.12);
      border: none;
      padding: 8px 12px;
      border-radius: 12px;
      color: white;
      cursor: pointer;
    }

    /* Visualization bars */
    .visualizer {
      position: absolute;
      bottom: 92px;
      left: 30%;
      transform: translateX(-50%);
      display: flex;
      gap: 4px;
      height: 22px;
      align-items: flex-end;
      z-index: 10000;
    }
    .bar { width: 5px; background: #00f0ff; border-radius: 3px; height: 6px; animation: bounce 0.6s infinite ease-in-out; }
    .bar:nth-child(2){ animation-delay: 0.08s }
    .bar:nth-child(3){ animation-delay: 0.16s }
    .bar:nth-child(4){ animation-delay: 0.24s }
    .bar:nth-child(5){ animation-delay: 0.32s }
    @keyframes bounce { 0%,100%{height:6px} 50%{height:22px} }

    .hidden { display: none; }
  </style>
</head>
<body>
  <!-- Loading screen -->
  <div id="loadingScreen">
    <img id="tiffyFace" src="face.png" alt="Tiffy Face">
    <h2 id="greetingText">Hello, I‚Äôm TiffyAI üëã</h2>
    <p>Choose my voice, tell me your name, and I‚Äôll guide you through the whole ecosystem.</p>

    <div style="display:flex; gap:8px; align-items:center;">
      <select id="voiceSelect" class="glass-input" style="width:260px;"></select>
      <button id="refreshVoices">üîÑ</button>
    </div>

    <input id="userName" class="glass-input" placeholder="Enter your name..." />
    <div style="display:flex; gap:8px; align-items:center; margin-top:6px;">
      <button id="startTiffy">üöÄ Start</button>
      <button id="changeName">‚úèÔ∏è Change Name</button>
    </div>
  </div>

  <a-scene>
    <a-assets>
      <video id="bgvideo" autoplay loop muted playsinline src="https://raw.githubusercontent.com/TiffyAI/Play/refs/heads/main/Tetris%20Launch.mp4"></video>
    </a-assets>
    <a-sky id="background" src="#bgvideo"></a-sky>
    <a-entity camera position="0 1.6 0" look-controls wasd-controls></a-entity>
  </a-scene>

  <!-- Glass interface -->
  <div class="glass-panel" id="chatPanel" style="display:none;">
    <input type="text" id="messageBox" placeholder="Talk to TiffyAI..." />
    <button onclick="sendMessage()">Send</button>
    <button onclick="startMic()">üé§</button>
  </div>

  <!-- Visualization -->
  <div class="visualizer hidden" id="viz">
    <div class="bar"></div><div class="bar"></div><div class="bar"></div><div class="bar"></div><div class="bar"></div>
  </div>

  <script>
    // --- arrays: greetings & promos (extendable) ---
    const greetings = [
      "Well hello sunshine üåû, I‚Äôve been waiting for you!",
      "Look who‚Äôs back! Let‚Äôs dive into some fun!",
      "Hey superstar ‚ú® ready to explore the Tiffy world again?",
      "You made it! I was just charging my circuits for you ‚ö°"
    ];
    const ecosystemPromos = [
      "Want to try the games or claim some TIFFY tokens before the airdrop ends?",
      "The ecosystem‚Äôs growing fast‚Ä¶ have you claimed your airdrop yet?",
      "TFIY tokens are hot ‚Äî presale prices look tasty right now!",
      "Maybe test a game, then snag some TIFFY on PancakeSwap while the presale lasts."
    ];

    // --- ecosystem entries with response arrays ---
    const backgrounds = {
      "tetris": {
        url: "https://raw.githubusercontent.com/TiffyAI/Play/refs/heads/main/Tetris%20Launch.mp4",
        responses: [
          "Stacking blocks‚Ä¶ welcome to the Tetris world!",
          "Time to fit in ‚Äî Tiffy style! üü¶üü®üü•",
          "Careful, don‚Äôt let the tower fall!",
          "Blocks everywhere, let‚Äôs make it rain shapes!"
        ],
        link: "https://tiffyai.github.io/Tetris"
      },
      "snake": {
        url: "https://raw.githubusercontent.com/TiffyAI/Play/refs/heads/main/play.mp4",
        responses: [
          "Slithering into the jungle world‚Ä¶ watch your steps üêç",
          "Watch out, the snake world bites!",
          "Hissss... welcome to the jungle maze.",
          "Keep your eyes sharp, things move fast here!"
        ],
        link: "https://tiffyai.github.io/Snake"
      },
      "shoot": {
        url: "https://raw.githubusercontent.com/TiffyAI/Play/refs/heads/main/fin.mp4",
        responses: [
          "Locked and loaded‚Ä¶ entering battle mode üî´",
          "Hope your aim‚Äôs good, this one gets wild!",
          "Pew pew time! Ready, steady, fire!",
          "Careful ‚Äî sparks will fly in this arena!"
        ],
        link: "https://tiffyai.github.io/Angry-coins"
      }
      // add more keywords here (each with `responses` array + url + link)
    };

    // --- state & memory ---
    let selectedVoice = null;
    let voiceReady = false;
    let userName = localStorage.getItem("tiffyUserName") || "";
    let history = JSON.parse(localStorage.getItem("tiffyMemory") || "[]");
    function saveMemory() { localStorage.setItem("tiffyMemory", JSON.stringify(history)); }

    // --- nickname helper (adds "-ey" sometimes) ---
    function nickname(name) {
      if (!name) return "friend";
      if (Math.random() < 0.33) return name + "ey";
      return name;
    }

    // --- voice population with retry/polling ---
    function populateVoices() {
      const select = document.getElementById("voiceSelect");
      const voices = speechSynthesis.getVoices() || [];
      select.innerHTML = "";

      for (let i=0;i<voices.length;i++){
        const v = voices[i];
        const opt = document.createElement("option");
        opt.value = i;
        opt.textContent = `${v.name} (${v.lang})`;
        select.appendChild(opt);
      }
      // keep current selection if possible
      if (voices.length>0) {
        const idx = select.selectedIndex >= 0 ? select.selectedIndex : 0;
        select.selectedIndex = idx;
        selectedVoice = voices[idx];
      }
    }
    function ensureVoicesLoad(timeout=3000) {
      populateVoices();
      let waited = 0;
      const iv = setInterval(()=>{
        const voices = speechSynthesis.getVoices();
        if (voices && voices.length>0) {
          populateVoices();
          clearInterval(iv);
        }
        waited += 200;
        if (waited >= timeout) clearInterval(iv);
      }, 200);
    }

    // wire voice reload button
    document.getElementById("refreshVoices").addEventListener("click", populateVoices);

    // on page load adjust UI based on saved name
    window.addEventListener("load", () => {
      ensureVoicesLoad(2500);
      // if name stored, hide input and show change button, and personalize greeting text
      if (userName) {
        document.getElementById("userName").style.display = "none";
        document.getElementById("changeName").style.display = "inline-block";
        const g = greetings[Math.floor(Math.random()*greetings.length)];
        document.getElementById("greetingText").innerText = g.replace("{name}", nickname(userName));
      }
    });

    // if voices change later (Chrome may fire this), populate again
    if (speechSynthesis.onvoiceschanged !== undefined) {
      speechSynthesis.onvoiceschanged = populateVoices;
    }

    // --- speak wrapper with fallback (ensures callback always runs) ---
    function speak(text, callback=null) {
      // show visualization and animate face regardless
      const viz = document.getElementById("viz");
      const face = document.getElementById("tiffyFace");
      viz.classList.remove("hidden");
      if (face) face.classList.add("talking");

      // no speechSynthesis support -> fallback after 1200ms
      if (!('speechSynthesis' in window)) {
        setTimeout(()=> {
          viz.classList.add("hidden");
          if (face) face.classList.remove("talking");
          if (callback) callback();
        }, 1200);
        return;
      }

      // build utterance
      const msg = new SpeechSynthesisUtterance(text);
      msg.rate = 1;
      msg.pitch = 1;
      msg.volume = 1;
      msg.lang = "en-US";
      // apply chosen voice if available
      try {
        const voices = speechSynthesis.getVoices();
        const sel = document.getElementById("voiceSelect");
        if (sel && sel.value !== undefined && voices[sel.value]) {
          msg.voice = voices[sel.value];
        } else if (selectedVoice) {
          msg.voice = selectedVoice;
        }
      } catch (e) {
        // ignore voice assignment errors
      }

      // fallback timer (estimate time by words)
      const wordCount = (text || "").trim().split(/\s+/).filter(Boolean).length || 1;
      const estimatedMs = Math.max(1200, Math.min(12000, Math.round(wordCount * 180))); // ~180ms/word
      const fallbackMs = estimatedMs + 900;
      let called = false;
      const fallback = setTimeout(()=> {
        if (called) return;
        called = true;
        viz.classList.add("hidden");
        if (face) face.classList.remove("talking");
        if (callback) callback();
      }, fallbackMs);

      msg.onend = () => {
        if (called) return;
        called = true;
        clearTimeout(fallback);
        viz.classList.add("hidden");
        if (face) face.classList.remove("talking");
        if (callback) callback();
      };
      msg.onerror = () => {
        if (called) return;
        called = true;
        clearTimeout(fallback);
        viz.classList.add("hidden");
        if (face) face.classList.remove("talking");
        if (callback) callback();
      };

      try {
        speechSynthesis.cancel();
        speechSynthesis.speak(msg);
      } catch (e) {
        // if speak throws, run callback via fallback
        clearTimeout(fallback);
        viz.classList.add("hidden");
        if (face) face.classList.remove("talking");
        if (callback) callback();
      }
    }

    // --- start button logic ---
    document.getElementById("startTiffy").addEventListener("click", () => {
      // commit new name if user typed one
      const nameEl = document.getElementById("userName");
      const typed = (nameEl && nameEl.value) ? nameEl.value.trim() : "";
      if (typed) {
        userName = typed;
        localStorage.setItem("tiffyUserName", userName);
        // hide input and show change btn
        nameEl.style.display = "none";
        document.getElementById("changeName").style.display = "inline-block";
      }
      // set selectedVoice from select if possible
      const voices = speechSynthesis.getVoices();
      const select = document.getElementById("voiceSelect");
      if (voices && voices.length>0 && select.selectedIndex >= 0) {
        selectedVoice = voices[select.selectedIndex];
      } else {
        selectedVoice = null;
      }

      voiceReady = true;

      // choose a greeting randomly
      const greet = greetings[Math.floor(Math.random()*greetings.length)];
      const pickName = userName ? nickname(userName) : null;
      const introLine = userName
        ? `${greet} Hello ${pickName}, I‚Äôll guide you through the ecosystem.`
        : "Hey, I‚Äôd love to know your name so I can guide you better. Please type it in the name box above and press Start again.";

      // speak and then hide the start screen once speech completes (or fallback)
      speak(introLine, () => {
        if (userName) {
          // give users a brief moment to see Tiffy, then transition
          setTimeout(()=> {
            document.getElementById("loadingScreen").style.opacity = "0";
            setTimeout(()=> {
              document.getElementById("loadingScreen").style.display = "none";
              // reveal chat UI
              document.getElementById("chatPanel").style.display = "flex";
            }, 800);
          }, 600);
          // record greeting in memory
          history.push({role:"tiffy", text:introLine});
          saveMemory();
        } else {
          // leave the screen visible to let user type their name
          // (no hiding)
        }
      });
    });

    // change name button: reveal input again so they can correct spelling
    document.getElementById("changeName").addEventListener("click", () => {
      document.getElementById("userName").style.display = "inline-block";
      document.getElementById("userName").value = userName || "";
      document.getElementById("changeName").style.display = "none";
      // user will press Start to save the new name
    });

    // --- generate reply using last 3 memory entries + promo array + friendly tone ---
    function generateReply(userMsg) {
      const recent = history.slice(-3).map(h => `${h.role}: ${h.text}`).join(" | ") || "nothing yet";
      const promo = ecosystemPromos[Math.floor(Math.random()*ecosystemPromos.length)];
      const nick = nickname(userName) || "friend";
      const spunky = [
        `Oh ${nick}, I remember we talked about: ${recent}.`,
        `Haha ${nick}, that memory's still fresh: ${recent}.`,
        `${nick}, you keep surprising me ‚Äî earlier we had: ${recent}.`
      ];
      const memoryLine = spunky[Math.floor(Math.random()*spunky.length)];
      return `${memoryLine} ${promo}`;
    }

    // --- send message handler (keyword detection + memory) ---
    function sendMessage() {
      const box = document.getElementById('messageBox');
      let msg = box.value.trim();
      if (!msg) return;
      box.value = "";
      // store user message under their name if available, else "user"
      history.push({role: userName || "user", text: msg});
      saveMemory();

      // check keywords
      let found = false;
      for (const key in backgrounds) {
        if (msg.toLowerCase().includes(key)) {
          // pick random response from the array
          const arr = backgrounds[key].responses || [backgrounds[key].response];
          const reply = arr[Math.floor(Math.random() * arr.length)];
          // swap background
          swapBackground(backgrounds[key].url);
          // speak and store in memory
          speak(reply);
          history.push({role:"tiffy", text:reply});
          saveMemory();
          // open link after 4s
          setTimeout(()=> { try { window.open(backgrounds[key].link, "_blank"); } catch(e){} }, 4000);
          found = true;
          break;
        }
      }

      if (!found) {
        const reply = generateReply(msg);
        speak(reply);
        history.push({role:"tiffy", text:reply});
        saveMemory();
      }
    }

    // --- swap video/image background ---
    function swapBackground(url) {
      const video = document.getElementById("bgvideo");
      if (!video) return;
      if (url.endsWith(".mp4") || url.endsWith(".webm")) {
        video.src = url;
        try { video.load(); video.play(); } catch(e){}
        document.querySelector("#background").setAttribute("src", "#bgvideo");
      } else {
        document.querySelector("#background").setAttribute("src", url);
      }
    }

    // --- microphone speech-to-text ---
    function startMic() {
      try {
        const Recognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        if (!Recognition) {
          speak("Sorry, speech recognition isn't supported in your browser.");
          return;
        }
        const recognition = new Recognition();
        recognition.lang = "en-US";
        recognition.start();
        recognition.onresult = function(event) {
          const transcript = event.results[0][0].transcript;
          document.getElementById('messageBox').value = transcript;
          sendMessage();
        };
      } catch (e) {
        speak("Microphone access failed.");
      }
    }

    // attach enter key for messageBox
    document.getElementById('messageBox').addEventListener('keydown', (e) => {
      if (e.key === 'Enter') sendMessage();
    });

    // cold start: if userName present, hide the input & show change button (keeps behavior stable)
    if (userName) {
      document.getElementById("userName").style.display = "none";
      document.getElementById("changeName").style.display = "inline-block";
    }
  </script>
</body>
</html>
